#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require

#include "raycommon.glsl"
#include "host_device.h"
#include "blending.glsl"

// used between intersection shader and closest-hit shader (can only be one attribute -> may need struct later)
hitAttributeEXT intersectionPayload intPayload;

layout(buffer_reference, scalar) buffer Vertices {Vertex v[]; }; // Positions of an object
layout(buffer_reference, scalar) buffer Indices {ivec3 i[]; }; // Triangle indices
layout(buffer_reference, scalar) buffer Materials {WaveFrontMaterial m[]; }; // Array of all materials on an object
layout(buffer_reference, scalar) buffer MatIndices {int i[]; }; // Material ID for each triangle
layout(buffer_reference, scalar) buffer Aabbs {Aabb b[]; }; // AABB for the triangle
layout(buffer_reference, scalar) buffer UVtoBs {mat3 m[]; }; // UV to barycentric coords for the triangle
layout(set = 1, binding = eDispObjDescs, scalar) buffer DispObjDesc_ { DispObjDesc i[]; } dispObjDesc;
layout(set = 1, binding = eTextures) uniform sampler2D textureSamplers[];

layout(push_constant) uniform _PushConstantRay { PushConstantRay pcRay; };

const int MAX_STEPS = 300;
const float STEP_SIZE = 0.1;

struct Ray
{
  vec3 origin;
  vec3 direction;
};

Ray ray;
Triangle triangle;

// UV to barycentric coordinates
mat3 uvToB;

// outward pointing normals in UV space like in Algorithm 4 in TFDM paper
vec2 n0, n1, n2;

// Ray-AABB intersection
float hitAabb(const Aabb aabb, const Ray r)
{
  // TODO: can precompute the inverse direction for multiple boxes!
  vec3  invDir = 1.0 / r.direction;
  vec3  tbot   = invDir * (aabb.minimum - r.origin);
  vec3  ttop   = invDir * (aabb.maximum - r.origin);
  vec3  tmin   = min(ttop, tbot);
  vec3  tmax   = max(ttop, tbot);
  float t0     = max(tmin.x, max(tmin.y, tmin.z));
  float t1     = min(tmax.x, min(tmax.y, tmax.z));
  return t1 > max(t0, 0.0) ? t0 : -1.0;
}

// Ray-Triangle intersection
// return.xy contains baryzentric coordinates of hit, return.z contains the tHit value
vec3 hitTriangle(const Triangle t, const Ray r)
{
  float eps = 0.000001;
  vec3 e1 = t.v1.pos - t.v0.pos;
  vec3 e2 = t.v2.pos - t.v0.pos;
  vec3 q = cross(r.direction, e2);
  float a = dot(e1, q);
  if (a > -eps && a < eps)
    return vec3(0,0,-1);
  float f = 1/a;
  vec3 s = r.origin - t.v0.pos;
  float u = f * dot(s, q);
  if (u < 0)
    return vec3(0,0,-1);
  vec3 z = cross(s, e1);
  float v = f * dot(r.direction, z);
  if (v < 0 || u + v > 1)
    return vec3(0,0,-1);
  float tHit = f * dot(e2, z);
  return vec3(u,v,tHit);
}

// stores the integer coordinate of a texel and the LoD level it belongs to
struct Texel
{
  ivec2 coord;
  int lod;
};

// used for texel comparison in "traversal()" function
bool texelEquals(Texel t1, Texel t2) {
  if (t1.coord == t2.coord && t1.lod == t2.lod)
    return true;
  return false;
}

// these functions are used for D-BVH traversal
void down(inout Texel texel) {
  texel.lod--;
  texel.coord *= 2;
  return;
}

// these functions are used for D-BVH traversal
void up(inout Texel texel) {
  texel.lod++;
  texel.coord /= 2;
  return;
}

// these functions are used for D-BVH traversal
//
// for each modulo 2x2 texel block, the "next" texel is:
// (0,0) -> (0,1)
// (0,1) -> (1,0)
// (1,0) -> (1,1)
// (1,1) -> raise LoD level and repeat
void next(inout Texel texel) {
  while (true) {
    switch (2*(texel.coord.x % 2) + texel.coord.y % 2) {

    // texelCoord = (0,1)
    case 1:
      texel.coord.y--;
      // FUN FACT: change this to "texel.coord++;" to produce fancy fractals
      texel.coord.x++;
      return;

    // texelCoord = (1,1)
    case 3:
      up(texel);
      continue;

    // texelCoord = (0,0) or (1,0)
    default:
      texel.coord.y++;
      return;
    }
  }
}

// naive root function that always starts at the highest possible LoD -> 1x1 texture
Texel root(Triangle triangle) {
  Texel result;
  result.coord = ivec2(0, 0);
  int lod = 0;
  while (textureSize(textureSamplers[nonuniformEXT(triangle.txtOffset)], lod).x != 1) {
    lod++;
  }
  result.lod = lod;
  return result;
}

// dot product between 2 affine forms of type (xC, xU, xV, xK)
vec4 affineFormDot(vec4 a, vec4 b) {
  vec4 result;
  result.x = a.x * b.x;
  result.y = a.y * b.x + a.x * b.y;
  result.z = a.z * b.x + a.x * b.z;
  result.w = abs(a.w * b.x) + abs(a.x * b.w) + (abs(a.y) + abs(a.z) + a.w) * (abs(b.y) + abs(b.z) + b.w);
  return result;
}

// displacement texture layout for channels: (linear, min, max, 1) -> minmax.y is min, minmax.z is max
Aabb box(Texel texel, mat3x3 pt, mat3x3 nt) {
  // 1. calculate affine form [h] of height range from minmax
  vec2 minmax = texelFetch(textureSamplers[nonuniformEXT(triangle.txtOffset)], texel.coord, texel.lod).yz * pcRay.displacementAmount;
  vec4 affineHeight = 0.5 * vec4(minmax.x + minmax.y, 0, 0, minmax.y - minmax.x);

  // 2. calculate affine form [uv] for the texel -> affine form layout: (xC, xU, xV, xK) -> see equation (12) of TFDM paper
  // layout: (xC, xU, xV, xK)
  ivec2 dimensions = textureSize(textureSamplers[nonuniformEXT(triangle.txtOffset)], 0);
  vec4 u = pow(2, texel.lod) * vec4((texel.coord.x + 0.5) / dimensions.x, 1.0 / (2 * dimensions.x), 0, 0);
  // layout: (xC, xU, xV, xK)
  vec4 v = pow(2, texel.lod) * vec4((texel.coord.y + 0.5) / dimensions.y, 0, 1.0 / (2 * dimensions.y), 0);

  // 3. calculate affine form [P] for position in 3D space
  mat4x3 uv1 = mat4x3(u.x, v.x, 1,
                      u.y, v.y, 0,
                      u.z, v.z, 0,
                      u.w, v.w, 0);

  mat4x3 affinePos = pt * uv1;

  // 4. calculate affine form [N] for normal in 3D space
  mat4x3 affineNrm = nt * uv1;

  // 5. calculate affine form [S] for displaced surface relative to given texel in 3D space -> [S] = [P] + [h] * [N]
  vec4 row1 = affineFormDot(affineHeight, vec4(affineNrm[0][0], affineNrm[1][0], affineNrm[2][0], affineNrm[3][0]));
  vec4 row2 = affineFormDot(affineHeight, vec4(affineNrm[0][1], affineNrm[1][1], affineNrm[2][1], affineNrm[3][1]));
  vec4 row3 = affineFormDot(affineHeight, vec4(affineNrm[0][2], affineNrm[1][2], affineNrm[2][2], affineNrm[3][2]));
  // the affine form [hn] = [h] * [N]
  mat4x3 hn = mat4x3(row1.x, row2.x, row3.x,
                     row1.y, row2.y, row3.y,
                     row1.z, row2.z, row3.z,
                     row1.w, row2.w, row3.w);
  mat4x3 affineDisp = affinePos + hn;

  // 6. calculate AABB from [S] according to equation (13) of TFDM paper
  Aabb result;
  // TODO: should maybe do this with vector operations in the future for better performance
  result.minimum = vec3(affineDisp[0][0] - abs(affineDisp[1][0]) - abs(affineDisp[2][0]) - abs(affineDisp[3][0]),
                        affineDisp[0][1] - abs(affineDisp[1][1]) - abs(affineDisp[2][1]) - abs(affineDisp[3][1]),
                        affineDisp[0][2] - abs(affineDisp[1][2]) - abs(affineDisp[2][2]) - abs(affineDisp[3][2]));
  result.maximum = vec3(affineDisp[0][0] + abs(affineDisp[1][0]) + abs(affineDisp[2][0]) + abs(affineDisp[3][0]),
                        affineDisp[0][1] + abs(affineDisp[1][1]) + abs(affineDisp[2][1]) + abs(affineDisp[3][1]),
                        affineDisp[0][2] + abs(affineDisp[1][2]) + abs(affineDisp[2][2]) + abs(affineDisp[3][2]));

  return result;
}

// Triangle-square 2D collision here (see Algorithm 4 of TFDM paper)
bool outside(Texel texel) {
  int texSize = textureSize(textureSamplers[nonuniformEXT(triangle.txtOffset)], texel.lod).x;
  vec2 c = vec2(texel.coord + 0.5) / texSize;
  float w = 1.0 / texSize;

  vec2 p0 = triangle.v0.texCoord - c;
  vec2 p1 = triangle.v1.texCoord - c;
  vec2 p2 = triangle.v2.texCoord - c;

  vec2 minimum = min(vec2(w, w), max(p0, max(p1, p2)));
  vec2 maximum = max(vec2(-w, -w), min(p0, min(p1, p2)));

  if (minimum.x <= maximum.x || minimum.y <= maximum.y) {
    return true;
  }
  vec2 sign0 = vec2(n0.x / abs(n0.x), n0.y / abs(n0.y));
  vec2 sign1 = vec2(n1.x / abs(n1.x), n1.y / abs(n1.y));
  vec2 sign2 = vec2(n2.x / abs(n2.x), n2.y / abs(n2.y));
  
  float dot0 = dot(n0, p0 + sign0 * w);
  float dot1 = dot(n1, p1 + sign1 * w);
  float dot2 = dot(n2, p2 + sign2 * w);
  if (dot0 <= 0 || dot1 <= 0 || dot2 <= 0) {
    return true;
  }

  return false;
}

// TODO: implement "box-intersection" -> for the "miss" evaluation this is already calculated -> reuse result
float local_intersection(Texel texel, Ray ray) {
  return -1;
}

// these functions are used for D-BVH traversal
float traversal(int targetLoD) {
  float tHit = -1;
  Texel texel, endtexel;
  texel = root(triangle);
  endtexel = root(triangle);
  next(endtexel);

  // UV to Barycentrics matrix is calculated on CPU (uvToB)
  mat3x3 pt = mat3x3(triangle.v0.pos, triangle.v1.pos, triangle.v2.pos) * uvToB;
  mat3x3 nt = mat3x3(triangle.v0.nrm, triangle.v1.nrm, triangle.v2.nrm) * uvToB;

  while (!texelEquals(texel, endtexel)) {
    if (outside(texel)) {
      next(texel);
      continue;
    }
    Aabb aabb = box(texel, pt, nt);
    // if the AABB should be clipped, not intersection test is performed
    float hitAABB = hitAabb(aabb, ray);
    //if (outside(texel, triangle) || miss(ray, box(texel, pt, nt)) {
    if (!(hitAABB < -1.0 || hitAABB > -1.0)) {
      next(texel);
    } else if (texel.lod <= targetLoD) {
      // TODO: implement "local_intersection()" function
      //float hit = local_intersection(texel, ray);
      float hit = hitAABB;
      if (hit >= 0 && (tHit < 0 || hit < tHit)) {
      // update intersection to the new intersection
        tHit = hit;
        // calculate texture coordinates for the closest hit shader 
        //   -> note: these are the texture coordinates for the middle of the texel (fixed for the AABB)
        intPayload.texCoord = vec2(texel.coord + 0.5) / textureSize(textureSamplers[nonuniformEXT(triangle.txtOffset)], texel.lod);
      }
      next(texel);
    } else {
      down(texel);
    }
  }
  // TODO: find a suitable normal calculation
  intPayload.worldNrm = vec3(0,1,0);
  return tHit;
}

// perform raymarching to calculate intersection with the displaced surface
float raymarching(Aabb aabb) {
  float tHitAABB = hitAabb(aabb, ray);

  // ray marching
  float tHit = -1;
  Ray march;
  march.origin = ray.origin + ray.direction * tHitAABB;
  march.direction = ray.direction;
  // TODO: find more accurate interpolation here
  vec3 normal = normalize(triangle.v0.nrm + triangle.v1.nrm + triangle.v2.nrm);
  Ray intersect;
  intersect.direction = -normal;
  
  for (int i = 0; i < MAX_STEPS; i++)
  {
    march.origin += STEP_SIZE * march.direction;
    intersect.origin = march.origin;
    vec3 baryzentrics = hitTriangle(triangle, intersect);
    vec2 texCoord = triangle.v0.texCoord * (1 - baryzentrics.x - baryzentrics.y) + triangle.v1.texCoord * baryzentrics.x 
                    + triangle.v2.texCoord * baryzentrics.y;

    // skips the height evaluation if the ray march origin is not located above the triangle
    if (baryzentrics.z < 0)
      continue;

    // experimental to calculate normal (https://stackoverflow.com/questions/5281261/generating-a-normal-map-from-a-height-map)
    // 4096x4096 is resolution of the height map

    // experimental tiling and blending
    float height = proceduralTilingAndBlending(texCoord, textureSamplers[nonuniformEXT(triangle.txtOffset)], pcRay.blendingOffset).x;
    height = clamp(height, 0, 1) * pcRay.displacementAmount;

    // TODO: ray marching only works for triangles parallel to the ground plane for now
    if (march.origin.y < height + triangle.v0.pos.y){
      tHit = STEP_SIZE * i;
      
      // TODO: should this be evaluated in the closest hit shader? -> new method for normal calculation from height map
      /*vec2 coordT, coordR, coordB, coordL;
      coordT = texCoord + vec2(0,1) * 1/4096;  //s12
      coordR = texCoord + vec2(1,0) * 1/4096;  //s21
      coordB = texCoord + vec2(0,-1) * 1/4096; //s10
      coordL = texCoord + vec2(-1,0) * 1/4096; //s01
      float top, right, bottom, left;
      top = proceduralTilingAndBlending(coordT, textureSamplers[nonuniformEXT(t.txtOffset)], pcRay.blendingOffset).x * pcRay.displacementAmount;
      right = proceduralTilingAndBlending(coordR, textureSamplers[nonuniformEXT(t.txtOffset)], pcRay.blendingOffset).x * pcRay.displacementAmount;
      bottom = proceduralTilingAndBlending(coordB, textureSamplers[nonuniformEXT(t.txtOffset)], pcRay.blendingOffset).x * pcRay.displacementAmount;
      left = proceduralTilingAndBlending(coordL, textureSamplers[nonuniformEXT(t.txtOffset)], pcRay.blendingOffset).x * pcRay.displacementAmount;

      vec3 va = normalize(vec3(2,0,right - left));
      vec3 vb = normalize(vec3(0,2,bottom - top));*/
      
      
      // setting world normal for use in closest-hit shader
      //intPayload.worldNrm = cross(va, vb).yzx;
      intPayload.texCoord = texCoord;
      intPayload.worldNrm = vec3(0,1,0);
      break;
    }
  }
  // if the raymarching hit something, tHit is greater than 0 and the tHitAABB should be added on top
  return tHit > 0 ? tHit + tHitAABB : -1;
}


void main()
{
  // Grab the ray
  ray.origin    = gl_WorldRayOriginEXT;
  ray.direction = gl_WorldRayDirectionEXT;

  // Grab the object description
  DispObjDesc  objResource = dispObjDesc.i[gl_InstanceCustomIndexEXT];
  MatIndices   matIndices  = MatIndices(objResource.materialIndexAddress);
  Materials    materials   = Materials(objResource.materialAddress);
  Indices      indices     = Indices(objResource.indexAddress);
  Vertices     vertices    = Vertices(objResource.vertexAddress);

  // Indices of the triangle
  ivec3 ind = indices.i[gl_PrimitiveID];
  
  // Vertex of the triangle
  Vertex v0 = vertices.v[ind.x];
  Vertex v1 = vertices.v[ind.y];
  Vertex v2 = vertices.v[ind.z];

  // Material of the object
  int               matIdx = matIndices.i[gl_PrimitiveID];
  WaveFrontMaterial mat    = materials.m[matIdx];

  // set triangle data that gets used by various intersection methods
  triangle.v0 = v0;
  triangle.v1 = v1;
  triangle.v2 = v2;
  triangle.txtOffset = mat.dispTextureID + dispObjDesc.i[gl_InstanceCustomIndexEXT].txtOffset;

  // if a triangle is not displaced
  if (mat.dispTextureID < 0 || pcRay.displacementAmount <= 0)
  {
    vec3 tHit = hitTriangle(triangle, ray);
    if (tHit.z < 0)
      return;
    intPayload.worldNrm = v0.nrm * (1 - tHit.x - tHit.y) + v1.nrm * tHit.x + v2.nrm * tHit.y;
    intPayload.texCoord = v0.texCoord * (1 - tHit.x - tHit.y) + v1.texCoord * tHit.x + v2.texCoord * tHit.y;
    reportIntersectionEXT(tHit.z, KIND_TRIANGLE);
    return;
  }

  float newHit = -1;
  if (pcRay.raymarching == 1) {
    // fetch AABB
    Aabb aabb = Aabbs(objResource.aabbAddress).b[gl_PrimitiveID];

    newHit = raymarching(aabb);
  } else if (pcRay.raymarching == 0) {
    // fetch UV to barycentrics matrix
    uvToB = UVtoBs(objResource.uvToBAddress).m[gl_PrimitiveID];

    // TODO: signum is 0, if all vertices are within one line, needs adjustment for degenerated triangles
    // compute outward facing normals in UV space for use in Triangle-square 2D collision
    // signum is 1, if vertices are clockwise, -1 else
    float signum = sign(determinant(mat3(v0.texCoord.x, v1.texCoord.x, v2.texCoord.x,
                                          v0.texCoord.y, v1.texCoord.y, v2.texCoord.y,
                                          1,             1,             1)));
    // TODO: find out if normalization is even necessary
    n0 = signum * normalize(v1.texCoord - v0.texCoord);
    n1 = signum * normalize(v2.texCoord - v1.texCoord);
    n2 = signum * normalize(v0.texCoord - v2.texCoord);

    // 90° clockwise rotation
    n0 = vec2(n0.y, -n0.x);
    n1 = vec2(n1.y, -n1.x);
    n2 = vec2(n2.y, -n2.x);

    newHit = traversal(pcRay.targetLod);
  } else {
    // procedural TFDM

    // calculate lattice coords for vertices
    vec2 l0 = uvToLattice(v0.texCoord, pcRay.blendingOffset);
    vec2 l1 = uvToLattice(v1.texCoord, pcRay.blendingOffset);
    vec2 l2 = uvToLattice(v2.texCoord, pcRay.blendingOffset);

    vec2 lMin = min(l0, min(l1, l2));
    vec2 lMax = max(l0, max(l1, l2));

    ivec2 lAlignedMin  = ivec2(floor(lMin));
    ivec2 lAlignedMax  = ivec2(ceil(lMax));
    int range = max(lAlignedMax.x - lAlignedMin.x, lAlignedMax.y - lAlignedMin.y);
    int power = 1;
    while(power < range)
      power *= 2;
    ivec2 lPowerOf2Max = lAlignedMax + power;

    while (range != 1) {
      //TODO: traverse lattice here -> in every iteration go "down" -> from 1 big cell to 4 smaller cells
    }
  }
  
  if (newHit > 0)
    reportIntersectionEXT(newHit, KIND_TRIANGLE);
}