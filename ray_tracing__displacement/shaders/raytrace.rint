#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require

#include "raycommon.glsl"
#include "host_device.h"
#include "blending.glsl"

// used between intersection shader and closest-hit shader (can only be one attribute -> may need struct later)
hitAttributeEXT intersectionPayload intPayload;

layout(buffer_reference, scalar) buffer Vertices {Vertex v[]; }; // Positions of an object
layout(buffer_reference, scalar) buffer Indices {ivec3 i[]; }; // Triangle indices
layout(buffer_reference, scalar) buffer Materials {WaveFrontMaterial m[]; }; // Array of all materials on an object
layout(buffer_reference, scalar) buffer MatIndices {int i[]; }; // Material ID for each triangle
layout(buffer_reference, scalar) buffer Aabbs {Aabb b[]; }; // AABB for the triangle
layout(set = 1, binding = eDispObjDescs, scalar) buffer DispObjDesc_ { DispObjDesc i[]; } dispObjDesc;
layout(set = 1, binding = eTextures) uniform sampler2D textureSamplers[];

layout(push_constant) uniform _PushConstantRay { PushConstantRay pcRay; };

const int MAX_STEPS = 300;
const float STEP_SIZE = 0.1;


struct Ray
{
  vec3 origin;
  vec3 direction;
};

// Ray-AABB intersection
float hitAabb(const Aabb aabb, const Ray r)
{
  vec3  invDir = 1.0 / r.direction;
  vec3  tbot   = invDir * (aabb.minimum - r.origin);
  vec3  ttop   = invDir * (aabb.maximum - r.origin);
  vec3  tmin   = min(ttop, tbot);
  vec3  tmax   = max(ttop, tbot);
  float t0     = max(tmin.x, max(tmin.y, tmin.z));
  float t1     = min(tmax.x, min(tmax.y, tmax.z));
  return t1 > max(t0, 0.0) ? t0 : -1.0;
}

// Ray-Triangle intersection
// return.xy contains baryzentric coordinates of hit, return.z contains the tHit value
vec3 hitTriangle(const Triangle t, const Ray r)
{
  float eps = 0.000001;
  vec3 e1 = t.v1.pos - t.v0.pos;
  vec3 e2 = t.v2.pos - t.v0.pos;
  vec3 q = cross(r.direction, e2);
  float a = dot(e1, q);
  if (a > -eps && a < eps)
    return vec3(0,0,-1);
  float f = 1/a;
  vec3 s = r.origin - t.v0.pos;
  float u = f * dot(s, q);
  if (u < 0)
    return vec3(0,0,-1);
  vec3 z = cross(s, e1);
  float v = f * dot(r.direction, z);
  if (v < 0 || u + v > 1)
    return vec3(0,0,-1);
  float tHit = f * dot(e2, z);
  return vec3(u,v,tHit);
}

// stores the integer coordinate of a texel and the LoD level it belongs to
struct Texel
{
  ivec2 coord;
  int lod;
};

// used for texel comparison in "traversal()" function
bool texelEquals(Texel t1, Texel t2) {
  if (t1.coord == t2.coord && t1.lod == t2.lod)
    return true;
  return false;
}

// these functions are used for D-BVH traversal
void down(inout Texel texel) {
  texel.lod--;
  texel.coord *= 2;
  return;
}

// these functions are used for D-BVH traversal
void up(inout Texel texel) {
  texel.lod++;
  texel.coord /= 2;
  return;
}

// these functions are used for D-BVH traversal
//
// for each modulo 2x2 texel block, the "next" texel is:
// (0,0) -> (0,1)
// (0,1) -> (1,0)
// (1,0) -> (1,1)
// (1,1) -> raise LoD level and repeat
void next(inout Texel texel) {
  // TODO: find suitable break condition -> this should only be a problem if "next()" is called on the bottom right texel (no matter the LoD)
  //       -> this may not be a problem as the "next()" of the last texel will only be used for coordinate comparison and not for sampling
  while (true) {
    switch (2*(texel.coord.x % 2) + texel.coord.y % 2) {

    // texelCoord = (0,1)
    case 1:
      texel.coord.y--;
      // TODO: in the paper there is "texelCoord++" but I think it has to be like this to fulfill purpose
      texel.coord.x++;
      return;

    // texelCoord = (1,1)
    case 3:
      up(texel);
      continue;

    // texelCoord = (0,0) or (1,0)
    default:
      texel.coord.y++;
      return;
    }
  }
}
/*
// these functions are used for D-BVH traversal
float traversal(Ray ray, Triangle triangle, int targetLoD) {
  float tHit = -1;
  Texel texel, endtexel;
  // TODO: implement "root()" function
  texel = root(triangle);
  endtexel = root(triangle);
  next(endtexel);

  while (!texelEquals(texel, endtexel)) {
    // implement "outside()", "miss()" and "box()" functions
    if (outside(texel, triangle) || miss(ray, box(texel)) {
      next(texel);
    } else if (texel.lod <= targetLoD) {
      // TODO: implement "local_intersection()" function
      float hit = local_intersection(texel, ray);
      if (hit >= 0)
        tHit = hit;
      next(texel);
    } else {
      down(texel);
    }
  }
  return tHit;
}*/

// perform raymarching to calculate intersection with the displaced surface
float raymarching(Ray ray, Triangle t, out vec2 outTexCoord, out vec3 outWorldNrm) {
  // ray marching
  float tHit = -1;
  Ray march;
  march.origin = ray.origin;
  march.direction = ray.direction;
  // TODO: find more accurate interpolation here
  vec3 normal = normalize(t.v0.nrm + t.v1.nrm + t.v2.nrm);
  Ray intersect;
  intersect.direction = -normal;
  
  for (int i = 0; i < MAX_STEPS; i++)
  {
    march.origin += STEP_SIZE * march.direction;
    intersect.origin = march.origin;
    vec3 baryzentrics = hitTriangle(t, intersect);
    vec2 texCoord = t.v0.texCoord * (1 - baryzentrics.x - baryzentrics.y) + t.v1.texCoord * baryzentrics.x + t.v2.texCoord * baryzentrics.y;

    // skips the height evaluation if the ray march origin is not located above the triangle
    if (baryzentrics.z < 0)
      continue;

    // experimental to calculate normal (https://stackoverflow.com/questions/5281261/generating-a-normal-map-from-a-height-map)
    // 4096x4096 is resolution of the height map

    // experimental tiling and blending
    float height = proceduralTilingAndBlending(texCoord, textureSamplers[nonuniformEXT(t.txtOffset)], pcRay.blendingOffset).x;
    height = clamp(height, 0, 1) * pcRay.displacementAmount;

    // TODO: ray marching should stop if exiting the bounding box
    // TODO: ray marching only works for triangles parallel to the ground plane for now
    if (march.origin.y < height + t.v0.pos.y){
      tHit = STEP_SIZE * i;
      
      // TODO: should this be evaluated in the closest hit shader? -> new method for normal calculation from height map
      vec2 coordT, coordR, coordB, coordL;
      coordT = texCoord + vec2(0,1) * 1/4096;  //s12
      coordR = texCoord + vec2(1,0) * 1/4096;  //s21
      coordB = texCoord + vec2(0,-1) * 1/4096; //s10
      coordL = texCoord + vec2(-1,0) * 1/4096; //s01
      float top, right, bottom, left;
      top = proceduralTilingAndBlending(coordT, textureSamplers[nonuniformEXT(t.txtOffset)], pcRay.blendingOffset).x * pcRay.displacementAmount;
      right = proceduralTilingAndBlending(coordR, textureSamplers[nonuniformEXT(t.txtOffset)], pcRay.blendingOffset).x * pcRay.displacementAmount;
      bottom = proceduralTilingAndBlending(coordB, textureSamplers[nonuniformEXT(t.txtOffset)], pcRay.blendingOffset).x * pcRay.displacementAmount;
      left = proceduralTilingAndBlending(coordL, textureSamplers[nonuniformEXT(t.txtOffset)], pcRay.blendingOffset).x * pcRay.displacementAmount;

      vec3 va = normalize(vec3(2,0,right - left));
      vec3 vb = normalize(vec3(0,2,bottom - top));
      
      
      // setting world normal for use in closest-hit shader
      //outWorldNrm = cross(va, vb).yzx;
      outTexCoord = texCoord;
      outWorldNrm = vec3(0,1,0);
      break;
    }
  }
  return tHit;
}


void main()
{
  // Grab the ray
  Ray ray;
  ray.origin    = gl_WorldRayOriginEXT;
  ray.direction = gl_WorldRayDirectionEXT;

  // Grab the object description
  DispObjDesc    objResource = dispObjDesc.i[gl_InstanceCustomIndexEXT];
  MatIndices matIndices      = MatIndices(objResource.materialIndexAddress);
  Materials  materials       = Materials(objResource.materialAddress);
  Indices    indices         = Indices(objResource.indexAddress);
  Vertices   vertices        = Vertices(objResource.vertexAddress);
  Aabbs aabbs                = Aabbs(objResource.aabbAddress);

  // Indices of the triangle
  ivec3 ind = indices.i[gl_PrimitiveID];
  
  // Vertex of the triangle
  Vertex v0 = vertices.v[ind.x];
  Vertex v1 = vertices.v[ind.y];
  Vertex v2 = vertices.v[ind.z];

  // Material of the object
  int               matIdx = matIndices.i[gl_PrimitiveID];
  WaveFrontMaterial mat    = materials.m[matIdx];

  Aabb aabb = aabbs.b[gl_PrimitiveID];

  Triangle triangle;
  triangle.v0 = v0;
  triangle.v1 = v1;
  triangle.v2 = v2;
  triangle.txtOffset = mat.dispTextureID + dispObjDesc.i[gl_InstanceCustomIndexEXT].txtOffset;

  float offset = pcRay.blendingOffset;

  // if a triangle is not displaced
  if (mat.dispTextureID < 0 || pcRay.displacementAmount <= 0)
  {
    vec3 tHit = hitTriangle(triangle, ray);
    if (tHit.z < 0)
      return;
    intPayload.worldNrm = v0.nrm * (1 - tHit.x - tHit.y) + v1.nrm * tHit.x + v2.nrm * tHit.y;
    intPayload.texCoord = v0.texCoord * (1 - tHit.x - tHit.y) + v1.texCoord * tHit.x + v2.texCoord * tHit.y;
    reportIntersectionEXT(tHit.z, KIND_TRIANGLE);
    return;
  }

  float tHitAABB = hitAabb(aabb, ray);

  Ray marchStart;
  marchStart.origin = ray.origin + ray.direction * tHitAABB;
  marchStart.direction = ray.direction;

  // calculate intersection point
  float newHit = raymarching(marchStart, triangle, intPayload.texCoord, intPayload.worldNrm);
  
  if (newHit > 0)
    reportIntersectionEXT(newHit + tHitAABB, KIND_TRIANGLE);

  /*
  // stencil for height
  vec3 hit = hitTriangle(triangle, ray);
  float tHit = hit.z;
  vec2 texCoord = v0.texCoord * (1 - hit.x - hit.y) + v1.texCoord * hit.x + v2.texCoord * hit.y;

  // sample displacement texture
  float mipLevel = 0;
  vec3 diffuse = textureLod(textureSampler, texCoord, mipLevel).xyz;
  diffuse = proceduralTilingAndBlending(texCoord, textureSampler);

  bool mask = diffuse.x < pcRay.displacementAmount;// && diffuse.y < 0.2 && diffuse.z < 0.2;
  // Report hit point
  intPayload.worldNrm = vec3(0,1,0);
  intPayload.texCoord = texCoord;
  if(tHit > 0 && mask)
    reportIntersectionEXT(tHit, KIND_TRIANGLE);
  */
}