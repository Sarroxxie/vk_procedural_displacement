#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require

#include "raycommon.glsl"
#include "wavefront.glsl"

// used between intersection shader and closest-hit shader (can only be one attribute -> may need struct later)
hitAttributeEXT vec3 worldNrm;

// retrieve triangles
layout(set = 1, binding = eImplicit, scalar) buffer allTriangles_
{
  Triangle allTriangles[];
};
layout(set = 1, binding = eTextures) uniform sampler2D textureSamplers[];

layout(push_constant) uniform _PushConstantRay { PushConstantRay pcRay; };

const int MAX_STEPS = 600;
const float STEP_SIZE = 0.15;


struct Ray
{
  vec3 origin;
  vec3 direction;
};

// Ray-AABB intersection
float hitAabb(const Aabb aabb, const Ray r)
{
  vec3  invDir = 1.0 / r.direction;
  vec3  tbot   = invDir * (aabb.minimum - r.origin);
  vec3  ttop   = invDir * (aabb.maximum - r.origin);
  vec3  tmin   = min(ttop, tbot);
  vec3  tmax   = max(ttop, tbot);
  float t0     = max(tmin.x, max(tmin.y, tmin.z));
  float t1     = min(tmax.x, min(tmax.y, tmax.z));
  return t1 > max(t0, 0.0) ? t0 : -1.0;
}

// Ray-Triangle intersection
vec3 hitTriangle(const Triangle t, const Ray r)
{
  float eps = 0.000001;
  vec3 e1 = t.v1.pos - t.v0.pos;
  vec3 e2 = t.v2.pos - t.v0.pos;
  vec3 q = cross(r.direction, e2);
  float a = dot(e1, q);
  if (a > -eps && a < eps)
    return vec3(0,0,-1);
  float f = 1/a;
  vec3 s = r.origin - t.v0.pos;
  float u = f * dot(s, q);
  if (u < 0)
    return vec3(0,0,-1);
  vec3 z = cross(s, e1);
  float v = f * dot(r.direction, z);
  if (v < 0 || u + v > 1)
    return vec3(0,0,-1);
  float tHit = f * dot(e2, z);
  return vec3(u,v,tHit);
}

void main()
{
  Ray ray;
  ray.origin    = gl_WorldRayOriginEXT;
  ray.direction = gl_WorldRayDirectionEXT;

  Triangle triangle = allTriangles[gl_PrimitiveID];

  // ray marching
  float newHit = -1;
  Ray march;
  march.origin = ray.origin;
  march.direction = ray.direction;

  for (int i = 0; i < MAX_STEPS; i++) {
    march.origin += STEP_SIZE * march.direction;
    // leads to some values being cut off falsely but kind of fixed the border of the AABB
    if (march.origin.y < 0)
      break;
    Ray intersect;
    intersect.origin = march.origin;
    intersect.direction = vec3(0,-1,0);
    vec3 baryzentrics = hitTriangle(triangle, intersect);
    vec2 texCoord = triangle.v0.texCoord * (1 - baryzentrics.x - baryzentrics.y) + triangle.v1.texCoord * baryzentrics.x + triangle.v2.texCoord * baryzentrics.y;
    float height = textureLod(textureSamplers[nonuniformEXT(triangle.txtOffset)], texCoord, 0).x * pcRay.displacementAmount;

    // experimental to calculate normal (https://stackoverflow.com/questions/5281261/generating-a-normal-map-from-a-height-map)
    // 4096x4096 is resolution of the height map
    ivec2 texelCoord = ivec2(texCoord * 4096);
    height = texelFetch(textureSamplers[nonuniformEXT(triangle.txtOffset)], texelCoord, 0).x * pcRay.displacementAmount;

    // TODO: ray marching should stop if exiting the bounding box
    if (march.origin.y < height) {
      newHit = STEP_SIZE * i;

      // TODO: this code should be evaluated in the closest hit shader -> new method for normal calculation from height map
      ivec2 coordT, coordR, coordB, coordL;
      coordT = texelCoord + ivec2(0,1);  //s12
      coordR = texelCoord + ivec2(1,0);  //s21
      coordB = texelCoord + ivec2(0,-1); //s10
      coordL = texelCoord + ivec2(-1,0); //s01
      float top, right, bottom, left;
      top = texelFetch(textureSamplers[nonuniformEXT(triangle.txtOffset)], coordT, 0).x * pcRay.displacementAmount;
      right = texelFetch(textureSamplers[nonuniformEXT(triangle.txtOffset)], coordR, 0).x * pcRay.displacementAmount;
      bottom = texelFetch(textureSamplers[nonuniformEXT(triangle.txtOffset)], coordB, 0).x * pcRay.displacementAmount;
      left = texelFetch(textureSamplers[nonuniformEXT(triangle.txtOffset)], coordL, 0).x * pcRay.displacementAmount;

      vec3 va = normalize(vec3(2,0,right - left));
      vec3 vb = normalize(vec3(0,2,bottom - top));
      // setting world normal for use in closest-hit shader
      worldNrm = cross(va, vb).yzx;
      break;
    }
  }

  if (newHit > 0)
    reportIntersectionEXT(newHit, KIND_TRIANGLE);

  /*
  // stencil for height
  vec3 hit = hitTriangle(triangle, ray);
  float tHit = hit.z;
  vec2 texCoord = triangle.v0.texCoord * (1 - hit.x - hit.y) + triangle.v1.texCoord * hit.x + triangle.v2.texCoord * hit.y;

  // sample displacement texture
  float mipLevel = 0;
  vec3 diffuse = textureLod(textureSamplers[nonuniformEXT(triangle.txtOffset)], texCoord, mipLevel).xyz;

  bool mask = diffuse.x < pcRay.displacementAmount;// && diffuse.y < 0.2 && diffuse.z < 0.2;
  // Report hit point
  if(tHit > 0 && mask)
    reportIntersectionEXT(tHit, KIND_TRIANGLE);
  */
}