#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require

#include "raycommon.glsl"
#include "wavefront.glsl"

// used between intersection shader and closest-hit shader (can only be one attribute -> may need struct later)
hitAttributeEXT intersectionPayload intPayload;

// retrieve triangles
layout(set = 1, binding = eImplicit, scalar) buffer allTriangles_
{
  Triangle allTriangles[];
};
layout(buffer_reference, scalar) buffer Vertices {Vertex v[]; }; // Positions of an object
layout(buffer_reference, scalar) buffer Indices {ivec3 i[]; }; // Triangle indices
layout(buffer_reference, scalar) buffer Materials {WaveFrontMaterial m[]; }; // Array of all materials on an object
layout(buffer_reference, scalar) buffer MatIndices {int i[]; }; // Material ID for each triangle
layout(buffer_reference, scalar) buffer Aabbs {Aabb b[]; }; // AABB for the triangle
layout(set = 1, binding = eDispObjDescs, scalar) buffer DispObjDesc_ { DispObjDesc i[]; } dispObjDesc;
layout(set = 1, binding = eTextures) uniform sampler2D textureSamplers[];

layout(push_constant) uniform _PushConstantRay { PushConstantRay pcRay; };

const int MAX_STEPS = 600;
const float STEP_SIZE = 0.05;


struct Ray
{
  vec3 origin;
  vec3 direction;
};

// Ray-AABB intersection
float hitAabb(const Aabb aabb, const Ray r)
{
  vec3  invDir = 1.0 / r.direction;
  vec3  tbot   = invDir * (aabb.minimum - r.origin);
  vec3  ttop   = invDir * (aabb.maximum - r.origin);
  vec3  tmin   = min(ttop, tbot);
  vec3  tmax   = max(ttop, tbot);
  float t0     = max(tmin.x, max(tmin.y, tmin.z));
  float t1     = min(tmax.x, min(tmax.y, tmax.z));
  return t1 > max(t0, 0.0) ? t0 : -1.0;
}

// Ray-Triangle intersection
// return.xy contains baryzentric coordinates of hit, return.z contains the tHit value
vec3 hitTriangle(const Triangle t, const Ray r)
{
  float eps = 0.000001;
  vec3 e1 = t.v1.pos - t.v0.pos;
  vec3 e2 = t.v2.pos - t.v0.pos;
  vec3 q = cross(r.direction, e2);
  float a = dot(e1, q);
  if (a > -eps && a < eps)
    return vec3(0,0,-1);
  float f = 1/a;
  vec3 s = r.origin - t.v0.pos;
  float u = f * dot(s, q);
  if (u < 0)
    return vec3(0,0,-1);
  vec3 z = cross(s, e1);
  float v = f * dot(r.direction, z);
  if (v < 0 || u + v > 1)
    return vec3(0,0,-1);
  float tHit = f * dot(e2, z);
  return vec3(u,v,tHit);
}

void main()
{
  // Grab the ray
  Ray ray;
  ray.origin    = gl_WorldRayOriginEXT;
  ray.direction = gl_WorldRayDirectionEXT;

  // Grab the object description
  DispObjDesc    objResource = dispObjDesc.i[gl_InstanceCustomIndexEXT];
  MatIndices matIndices      = MatIndices(objResource.materialIndexAddress);
  Materials  materials       = Materials(objResource.materialAddress);
  Indices    indices         = Indices(objResource.indexAddress);
  Vertices   vertices        = Vertices(objResource.vertexAddress);
  Aabbs aabbs                = Aabbs(objResource.aabbAddress);

  // Indices of the triangle
  ivec3 ind = indices.i[gl_PrimitiveID];

  // Vertex of the triangle
  Vertex v0 = vertices.v[ind.x];
  Vertex v1 = vertices.v[ind.y];
  Vertex v2 = vertices.v[ind.z];

  // Material of the object
  int               matIdx = matIndices.i[gl_PrimitiveID];
  WaveFrontMaterial mat    = materials.m[matIdx];

  Triangle triangle;
  triangle.v0 = v0;
  triangle.v1 = v1;
  triangle.v2 = v2;
  triangle.txtOffset = mat.dispTextureID;

  // if a triangle is not displaced
  if (mat.dispTextureID < 0 || pcRay.displacementAmount <= 0)
  {
    vec3 tHit = hitTriangle(triangle, ray);
    if (tHit.z < 0)
      return;
    intPayload.worldNrm = triangle.v0.nrm * (1 - tHit.x - tHit.y) + triangle.v1.nrm * tHit.x + triangle.v2.nrm * tHit.y;
    intPayload.texCoord = triangle.v0.texCoord * (1 - tHit.x - tHit.y) + triangle.v1.texCoord * tHit.x + triangle.v2.texCoord * tHit.y;
    reportIntersectionEXT(tHit.z, KIND_TRIANGLE);
    return;
  }

  float tHitAABB = hitAabb(aabbs.b[gl_PrimitiveID], ray);

  // ray marching
  float newHit = -1;
  // start raymarching at hit with AABB and in direction of the ray
  Ray march;
  march.origin = ray.origin + ray.direction * tHitAABB;
  march.direction = ray.direction;

  for (int i = 0; i < MAX_STEPS; i++)
  {
    march.origin += STEP_SIZE * march.direction;
    // leads to some values being cut off falsely but kind of fixed the border of the AABB
    if (march.origin.y < 0)
      break;
    Ray intersect;
    intersect.origin = march.origin;
    intersect.direction = vec3(0,-1,0);
    vec3 baryzentrics = hitTriangle(triangle, intersect);
    vec2 texCoord = triangle.v0.texCoord * (1 - baryzentrics.x - baryzentrics.y) + triangle.v1.texCoord * baryzentrics.x + triangle.v2.texCoord * baryzentrics.y;
    float height = textureLod(textureSamplers[nonuniformEXT(triangle.txtOffset)], texCoord, 0).x * pcRay.displacementAmount;

    // experimental to calculate normal (https://stackoverflow.com/questions/5281261/generating-a-normal-map-from-a-height-map)
    // 4096x4096 is resolution of the height map
    ivec2 texelCoord = ivec2(texCoord * 4096);
    height = texelFetch(textureSamplers[nonuniformEXT(triangle.txtOffset)], texelCoord, 0).x * pcRay.displacementAmount;

    // TODO: ray marching should stop if exiting the bounding box
    if (march.origin.y < height) {
      newHit = STEP_SIZE * i;

      // TODO: should this be evaluated in the closest hit shader? -> new method for normal calculation from height map
      ivec2 coordT, coordR, coordB, coordL;
      coordT = texelCoord + ivec2(0,1);  //s12
      coordR = texelCoord + ivec2(1,0);  //s21
      coordB = texelCoord + ivec2(0,-1); //s10
      coordL = texelCoord + ivec2(-1,0); //s01
      float top, right, bottom, left;
      top = texelFetch(textureSamplers[nonuniformEXT(triangle.txtOffset)], coordT, 0).x * pcRay.displacementAmount;
      right = texelFetch(textureSamplers[nonuniformEXT(triangle.txtOffset)], coordR, 0).x * pcRay.displacementAmount;
      bottom = texelFetch(textureSamplers[nonuniformEXT(triangle.txtOffset)], coordB, 0).x * pcRay.displacementAmount;
      left = texelFetch(textureSamplers[nonuniformEXT(triangle.txtOffset)], coordL, 0).x * pcRay.displacementAmount;

      vec3 va = normalize(vec3(2,0,right - left));
      vec3 vb = normalize(vec3(0,2,bottom - top));
      // setting world normal for use in closest-hit shader
      intPayload.worldNrm = cross(va, vb).yzx;
      intPayload.texCoord = texCoord;
      break;
    }
  }

  if (newHit > 0)
    reportIntersectionEXT(newHit + tHitAABB, KIND_TRIANGLE);
  
  /*

  
  // stencil for height
  vec3 hit = hitTriangle(triangle, ray);
  float tHit = hit.z;
  vec2 texCoord = triangle.v0.texCoord * (1 - hit.x - hit.y) + triangle.v1.texCoord * hit.x + triangle.v2.texCoord * hit.y;

  // sample displacement texture
  float mipLevel = 0;
  vec3 diffuse = textureLod(textureSamplers[nonuniformEXT(triangle.txtOffset)], texCoord, mipLevel).xyz;

  bool mask = diffuse.x < pcRay.displacementAmount;// && diffuse.y < 0.2 && diffuse.z < 0.2;
  // Report hit point
  if(tHit > 0 && mask)
    reportIntersectionEXT(tHit, KIND_TRIANGLE);
  */
}