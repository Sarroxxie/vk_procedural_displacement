#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require

#include "raycommon.glsl"
#include "host_device.h"
#include "blending.glsl"

// used between intersection shader and closest-hit shader (can only be one attribute -> may need struct later)
hitAttributeEXT intersectionPayload intPayload;

layout(buffer_reference, scalar) buffer Vertices {Vertex v[]; }; // Positions of an object
layout(buffer_reference, scalar) buffer Indices {ivec3 i[]; }; // Triangle indices
layout(buffer_reference, scalar) buffer Materials {WaveFrontMaterial m[]; }; // Array of all materials on an object
layout(buffer_reference, scalar) buffer MatIndices {int i[]; }; // Material ID for each triangle
layout(buffer_reference, scalar) buffer Aabbs {Aabb b[]; }; // AABB for the triangle
layout(buffer_reference, scalar) buffer UVtoBs {mat3 m[]; }; // UV to barycentric coords for the triangle
layout(set = 1, binding = eDispObjDescs, scalar) buffer DispObjDesc_ { DispObjDesc i[]; } dispObjDesc;
layout(set = 1, binding = eTextures) uniform sampler2D textureSamplers[];

layout(push_constant) uniform _PushConstantRay { PushConstantRay pcRay; };

const int MAX_STEPS = 300;
const float STEP_SIZE = 0.1;
// used for triforce descend -> count of how 1x1 lattice texel gets partitioned
const int MAX_RANGE = 4;

struct Ray
{
  vec3 origin;
  vec3 direction;
};

Ray ray;
Triangle triangle;

// UV to barycentric coordinates
mat3 uvToB;

// lattice to barycentric coordinates
mat3 lToB;

// global minmax
vec2 globalMinMax;

// outward pointing normals in UV space like in Algorithm 4 in TFDM paper
vec2 n0, n1, n2;

// Ray-AABB intersection
float hitAabb(const Aabb aabb, const Ray r)
{
  // TODO: can precompute the inverse direction for multiple boxes!
  vec3  invDir = 1.0 / r.direction;
  vec3  tbot   = invDir * (aabb.minimum - r.origin);
  vec3  ttop   = invDir * (aabb.maximum - r.origin);
  vec3  tmin   = min(ttop, tbot);
  vec3  tmax   = max(ttop, tbot);
  float t0     = max(tmin.x, max(tmin.y, tmin.z));
  float t1     = min(tmax.x, min(tmax.y, tmax.z));
  return t1 > max(t0, 0.0) ? t0 : -1.0;
}

// Ray-Triangle intersection
// return.xy contains baryzentric coordinates of hit, return.z contains the tHit value
vec3 hitTriangle(const Triangle t, const Ray r)
{
  float eps = 0.000001;
  vec3 e1 = t.v1.pos - t.v0.pos;
  vec3 e2 = t.v2.pos - t.v0.pos;
  vec3 q = cross(r.direction, e2);
  float a = dot(e1, q);
  if (a > -eps && a < eps)
    return vec3(0,0,-1);
  float f = 1/a;
  vec3 s = r.origin - t.v0.pos;
  float u = f * dot(s, q);
  if (u < 0)
    return vec3(0,0,-1);
  vec3 z = cross(s, e1);
  float v = f * dot(r.direction, z);
  if (v < 0 || u + v > 1)
    return vec3(0,0,-1);
  float tHit = f * dot(e2, z);
  return vec3(u,v,tHit);
}

// -----------------------------------------------------------------------------------------------------------
// Tessellation-Free Displacement Mapping

// stores the integer coordinate of a texel and the LoD level it belongs to
struct Texel
{
  ivec2 coord;
  int lod;
};

// used for texel comparison in "traversal()" function
bool texelEquals(Texel t1, Texel t2) {
  if (t1.coord == t2.coord && t1.lod == t2.lod)
    return true;
  return false;
}

// these functions are used for D-BVH traversal
void down(inout Texel texel) {
  texel.lod--;
  texel.coord *= 2;
  return;
}

// these functions are used for D-BVH traversal
void up(inout Texel texel) {
  texel.lod++;
  texel.coord /= 2;
  return;
}

// these functions are used for D-BVH traversal
//
// for each modulo 2x2 texel block, the "next" texel is:
// (0,0) -> (0,1)
// (0,1) -> (1,0)
// (1,0) -> (1,1)
// (1,1) -> raise LoD level and repeat
void next(inout Texel texel) {
  while (true) {
    switch (2*(texel.coord.x % 2) + texel.coord.y % 2) {

    // texelCoord = (0,1)
    case 1:
      texel.coord.y--;
      // FUN FACT: change this to "texel.coord++;" to produce fancy fractals
      texel.coord.x++;
      return;

    // texelCoord = (1,1)
    case 3:
      up(texel);
      continue;

    // texelCoord = (0,0) or (1,0)
    default:
      texel.coord.y++;
      return;
    }
  }
}

// naive root function that always starts at the highest possible LoD -> 1x1 texture
Texel root(Triangle triangle) {
  Texel result;
  result.coord = ivec2(0, 0);
  int lod = 0;
  while (textureSize(textureSamplers[nonuniformEXT(triangle.txtOffset)], lod).x != 1) {
    lod++;
  }
  result.lod = lod;
  return result;
}

// dot product between 2 affine forms of type (xC, xU, xV, xK)
vec4 affineFormDot(vec4 a, vec4 b) {
  vec4 result;
  result.x = a.x * b.x;
  result.y = a.y * b.x + a.x * b.y;
  result.z = a.z * b.x + a.x * b.z;
  result.w = abs(a.w * b.x) + abs(a.x * b.w) + (abs(a.y) + abs(a.z) + a.w) * (abs(b.y) + abs(b.z) + b.w);
  return result;
}

// displacement texture layout for channels: (linear, min, max, 1) -> minmax.y is min, minmax.z is max
Aabb box(Texel texel, mat3x3 pt, mat3x3 nt) {
  // 1. calculate affine form [h] of height range from minmax
  vec2 minmax = texelFetch(textureSamplers[nonuniformEXT(triangle.txtOffset)], texel.coord, texel.lod).yz * pcRay.displacementAmount;
  vec4 affineHeight = 0.5 * vec4(minmax.x + minmax.y, 0, 0, minmax.y - minmax.x);

  // 2. calculate affine form [uv] for the texel -> affine form layout: (xC, xU, xV, xK) -> see equation (12) of TFDM paper
  // layout: (xC, xU, xV, xK)
  ivec2 dimensions = textureSize(textureSamplers[nonuniformEXT(triangle.txtOffset)], 0);
  vec4 u = pow(2, texel.lod) * vec4((texel.coord.x + 0.5) / dimensions.x, 1.0 / (2 * dimensions.x), 0, 0);
  // layout: (xC, xU, xV, xK)
  vec4 v = pow(2, texel.lod) * vec4((texel.coord.y + 0.5) / dimensions.y, 0, 1.0 / (2 * dimensions.y), 0);

  // 3. calculate affine form [P] for position in 3D space
  mat4x3 uv1 = mat4x3(u.x, v.x, 1,
                      u.y, v.y, 0,
                      u.z, v.z, 0,
                      u.w, v.w, 0);

  mat4x3 affinePos = pt * uv1;

  // 4. calculate affine form [N] for normal in 3D space
  mat4x3 affineNrm = nt * uv1;

  // 5. calculate affine form [S] for displaced surface relative to given texel in 3D space -> [S] = [P] + [h] * [N]
  vec4 row1 = affineFormDot(affineHeight, vec4(affineNrm[0][0], affineNrm[1][0], affineNrm[2][0], affineNrm[3][0]));
  vec4 row2 = affineFormDot(affineHeight, vec4(affineNrm[0][1], affineNrm[1][1], affineNrm[2][1], affineNrm[3][1]));
  vec4 row3 = affineFormDot(affineHeight, vec4(affineNrm[0][2], affineNrm[1][2], affineNrm[2][2], affineNrm[3][2]));
  // the affine form [hn] = [h] * [N]
  mat4x3 hn = mat4x3(row1.x, row2.x, row3.x,
                     row1.y, row2.y, row3.y,
                     row1.z, row2.z, row3.z,
                     row1.w, row2.w, row3.w);
  mat4x3 affineDisp = affinePos + hn;

  // 6. calculate AABB from [S] according to equation (13) of TFDM paper
  Aabb result;
  // TODO: should maybe do this with vector operations in the future for better performance
  result.minimum = vec3(affineDisp[0][0] - abs(affineDisp[1][0]) - abs(affineDisp[2][0]) - abs(affineDisp[3][0]),
                        affineDisp[0][1] - abs(affineDisp[1][1]) - abs(affineDisp[2][1]) - abs(affineDisp[3][1]),
                        affineDisp[0][2] - abs(affineDisp[1][2]) - abs(affineDisp[2][2]) - abs(affineDisp[3][2]));
  result.maximum = vec3(affineDisp[0][0] + abs(affineDisp[1][0]) + abs(affineDisp[2][0]) + abs(affineDisp[3][0]),
                        affineDisp[0][1] + abs(affineDisp[1][1]) + abs(affineDisp[2][1]) + abs(affineDisp[3][1]),
                        affineDisp[0][2] + abs(affineDisp[1][2]) + abs(affineDisp[2][2]) + abs(affineDisp[3][2]));

  return result;
}

// Triangle-square 2D collision here (see Algorithm 4 of TFDM paper)
bool outside(Texel texel) {
  int texSize = textureSize(textureSamplers[nonuniformEXT(triangle.txtOffset)], texel.lod).x;
  vec2 c = vec2(texel.coord + 0.5) / texSize;
  float w = 1.0 / texSize;

  vec2 p0 = triangle.v0.texCoord - c;
  vec2 p1 = triangle.v1.texCoord - c;
  vec2 p2 = triangle.v2.texCoord - c;

  vec2 minimum = min(vec2(w, w), max(p0, max(p1, p2)));
  vec2 maximum = max(vec2(-w, -w), min(p0, min(p1, p2)));

  if (minimum.x <= maximum.x || minimum.y <= maximum.y) {
    return true;
  }
  vec2 sign0 = vec2(n0.x / abs(n0.x), n0.y / abs(n0.y));
  vec2 sign1 = vec2(n1.x / abs(n1.x), n1.y / abs(n1.y));
  vec2 sign2 = vec2(n2.x / abs(n2.x), n2.y / abs(n2.y));
  
  float dot0 = dot(n0, p0 + sign0 * w);
  float dot1 = dot(n1, p1 + sign1 * w);
  float dot2 = dot(n2, p2 + sign2 * w);
  if (dot0 <= 0 || dot1 <= 0 || dot2 <= 0) {
    return true;
  }

  return false;
}

// TODO: implement "box-intersection" -> for the "miss" evaluation this is already calculated -> reuse result
float local_intersection(Texel texel, Ray ray) {
  return -1;
}

// these functions are used for D-BVH traversal
float traversal(int targetLoD) {
  float tHit = -1;
  Texel texel, endtexel;
  texel = root(triangle);
  endtexel = root(triangle);
  next(endtexel);

  // UV to Barycentrics matrix is calculated on CPU (uvToB)
  mat3x3 pt = mat3x3(triangle.v0.pos, triangle.v1.pos, triangle.v2.pos) * uvToB;
  mat3x3 nt = mat3x3(triangle.v0.nrm, triangle.v1.nrm, triangle.v2.nrm) * uvToB;

  while (!texelEquals(texel, endtexel)) {
    if (outside(texel)) {
      next(texel);
      continue;
    }
    Aabb aabb = box(texel, pt, nt);
    // if the AABB should be clipped, not intersection test is performed
    float hitAABB = hitAabb(aabb, ray);
    //if (outside(texel, triangle) || miss(ray, box(texel, pt, nt)) {
    if (!(hitAABB < -1.0 || hitAABB > -1.0)) {
      next(texel);
    } else if (texel.lod <= targetLoD) {
      // TODO: implement "local_intersection()" function
      //float hit = local_intersection(texel, ray);
      float hit = hitAABB;
      if (hit >= 0 && (tHit < 0 || hit < tHit)) {
      // update intersection to the new intersection
        tHit = hit;
        // calculate texture coordinates for the closest hit shader 
        //   -> note: these are the texture coordinates for the middle of the texel (fixed for the AABB)
        intPayload.texCoord = vec2(texel.coord + 0.5) / textureSize(textureSamplers[nonuniformEXT(triangle.txtOffset)], texel.lod);
      }
      next(texel);
    } else {
      down(texel);
    }
  }
  // TODO: find a suitable normal calculation
  intPayload.worldNrm = vec3(0,1,0);
  return tHit;
}

// -----------------------------------------------------------------------------------------------------------
// raymarching

// perform raymarching to calculate intersection with the displaced surface
float raymarching(Aabb aabb) {
  float tHitAABB = hitAabb(aabb, ray);

  // ray marching
  float tHit = -1;
  Ray march;
  march.origin = ray.origin + ray.direction * tHitAABB;
  march.direction = ray.direction;
  // TODO: find more accurate interpolation here
  vec3 normal = normalize(triangle.v0.nrm + triangle.v1.nrm + triangle.v2.nrm);
  Ray intersect;
  intersect.direction = -normal;
  
  for (int i = 0; i < MAX_STEPS; i++)
  {
    march.origin += STEP_SIZE * march.direction;
    intersect.origin = march.origin;
    vec3 baryzentrics = hitTriangle(triangle, intersect);
    vec2 texCoord = triangle.v0.texCoord * (1 - baryzentrics.x - baryzentrics.y) + triangle.v1.texCoord * baryzentrics.x 
                    + triangle.v2.texCoord * baryzentrics.y;

    // skips the height evaluation if the ray march origin is not located above the triangle
    if (baryzentrics.z < 0)
      continue;

    // experimental to calculate normal (https://stackoverflow.com/questions/5281261/generating-a-normal-map-from-a-height-map)
    // 4096x4096 is resolution of the height map

    // experimental tiling and blending
    float height = proceduralTilingAndBlending(texCoord, textureSamplers[nonuniformEXT(triangle.txtOffset)], pcRay.blendingOffset).x;
    height = clamp(height, 0, 1) * pcRay.displacementAmount;

    // TODO: ray marching only works for triangles parallel to the ground plane for now
    if (march.origin.y < height + triangle.v0.pos.y){
      tHit = STEP_SIZE * i;
      
      // TODO: should this be evaluated in the closest hit shader? -> new method for normal calculation from height map
      /*vec2 coordT, coordR, coordB, coordL;
      coordT = texCoord + vec2(0,1) * 1/4096;  //s12
      coordR = texCoord + vec2(1,0) * 1/4096;  //s21
      coordB = texCoord + vec2(0,-1) * 1/4096; //s10
      coordL = texCoord + vec2(-1,0) * 1/4096; //s01
      float top, right, bottom, left;
      top = proceduralTilingAndBlending(coordT, textureSamplers[nonuniformEXT(t.txtOffset)], pcRay.blendingOffset).x * pcRay.displacementAmount;
      right = proceduralTilingAndBlending(coordR, textureSamplers[nonuniformEXT(t.txtOffset)], pcRay.blendingOffset).x * pcRay.displacementAmount;
      bottom = proceduralTilingAndBlending(coordB, textureSamplers[nonuniformEXT(t.txtOffset)], pcRay.blendingOffset).x * pcRay.displacementAmount;
      left = proceduralTilingAndBlending(coordL, textureSamplers[nonuniformEXT(t.txtOffset)], pcRay.blendingOffset).x * pcRay.displacementAmount;

      vec3 va = normalize(vec3(2,0,right - left));
      vec3 vb = normalize(vec3(0,2,bottom - top));*/
      
      
      // setting world normal for use in closest-hit shader
      //intPayload.worldNrm = cross(va, vb).yzx;
      intPayload.texCoord = texCoord;
      intPayload.worldNrm = vec3(0,1,0);
      break;
    }
  }
  // if the raymarching hit something, tHit is greater than 0 and the tHitAABB should be added on top
  return tHit > 0 ? tHit + tHitAABB : -1;
}

// -----------------------------------------------------------------------------------------------------------
// triforce descend

// centers of hexagons hashed from v0, v1 and v2 of rootLatticeTriangle
vec2 h0_0, h0_1, h0_2;
vec2 h1_0, h1_1, h1_2;
vec2 h2_0, h2_1, h2_2;
bool isRangeNegative;

struct LatticeTexel
{
  ivec2 lMin;
  // range always has to be power of 2!
  int range;
  // 0: botLeft
  // 1: topLeft
  // 2: botRight
  // 3: topRight
  int counter;
};

struct LatticeTriangle
{
  ivec2 base;
  int range;
  int counter;
};

bool latticeTriangleEquals(LatticeTriangle t1, LatticeTriangle t2) {
  if (t1.base == t2.base && t1.range == t2.range && t1.counter == t2.counter)
    return true;
  return false;
}

void triforceDown(inout LatticeTriangle lTriangle) {
  lTriangle.range /= 2;
  lTriangle.counter = 0;
}

void triforceUp(inout LatticeTriangle lTriangle) {
  lTriangle.base += lTriangle.range;
  lTriangle.range *= -2;
  ivec2 temp = lTriangle.base % (lTriangle.range * 2);
  temp = ivec2(temp / lTriangle.range) % 2;
  lTriangle.counter = 2 * temp.x + temp.y;
}

void triforceNext(inout LatticeTriangle lTriangle) {
  // TODO: need to set the MAX_RANGE somewhere
  // highest level, where there are only 2 triangles that form one 1x1 LatticeTexel
  while (true) {
    if (abs(lTriangle.range) == MAX_RANGE) {
      lTriangle.base += lTriangle.range;
      lTriangle.range = -lTriangle.range;
      lTriangle.counter++;
      return;
    }
    switch(lTriangle.counter) {
	// texelCoord = (0,1)
    case 1:
      lTriangle.base += ivec2(lTriangle.range, -lTriangle.range);
	  lTriangle.counter++;
      return;

    case 2:
      lTriangle.base.y += lTriangle.range;
      lTriangle.range = -lTriangle.range;
      lTriangle.counter++;
      return;

    // texelCoord = (1,1)
    case 3:
      triforceUp(lTriangle);
      continue;

    // texelCoord = (0,0) or (1,0)
    default:
      lTriangle.base.y += lTriangle.range;
	  lTriangle.counter++;
      return;
	}
  }
}

bool triforceOutside(LatticeTriangle lTriangle) {
  return false;
}

// checks if a triangle (defined by points p0, p1, p2) in UV space is fully inside a texel
vec2 heightFromUVTriangle(vec2 uv0, vec2 uv1, vec2 uv2) {
  vec2 minimum = min(uv0, min(uv1, uv2));
  vec2 maximum = max(uv0, max(uv1, uv2));
  float range  = max(maximum.x - minimum.x, maximum.y - minimum.y);
  int lod = 0;
  float texelRange = 1;
  while (range < texelRange / 2) {
    lod++;
    texelRange /= 2;
  }
  int lodSize = textureSize(textureSamplers[nonuniformEXT(triangle.txtOffset)], lod).x;
  ivec2 minimumTexel = ivec2(floor(minimum * lodSize));
  ivec2 maximumTexel = ivec2(floor(maximum * lodSize));
  vec2 minmax = vec2(1, 0);
  for (int x = minimumTexel.x; x < maximumTexel.x; x++) {
    for (int y = minimumTexel.y; y < maximumTexel.y; y++) {
      vec2 texel = texelFetch(textureSamplers[nonuniformEXT(triangle.txtOffset)], ivec2(x,y), lod).yz;
      minmax.x = min(minmax.x, texel.x);
      minmax.y = max(minmax.y, texel.y);
    }
  }
  return minmax;
}

// will calculate the barycentrics of a point that is known to be inside a LatticeTriangle with range = MAX_RANGE (-> isRangeNegative = false) or
// with range = -MAX_RANGE (-> isRangeNegative = true)
// for detailed description see notes!!
vec2 barycentricsFromLatticeTriangle(ivec2 p) {
  vec2 barycentrics;
  float inverseMaxRange = 1.0 / MAX_RANGE;
  // TODO: make sure that all divisions are floating point operations
  if (isRangeNegative) {
    barycentrics.y = abs(MAX_RANGE - p.y) * inverseMaxRange;
    barycentrics.x = 1 - barycentrics.y - (abs(MAX_RANGE - p.x) * inverseMaxRange);
  } else {
    barycentrics.y = p.y * inverseMaxRange;
    barycentrics.x = 1 - barycentrics.y - (p.x * inverseMaxRange);
  }
  return barycentrics;
}

// TODO: implement this bounding box generation -> need to take the blending into account here
// TODO: instead of LatticeTexel root, use LatticeTriangle root, as its vertices are needed for barycentrics calculation
Aabb triforceBox(LatticeTriangle lTriangle, LatticeTexel root, mat3x3 pt, mat3x3 nt) {
  // TODO: fill this method, this only makes shader compilation possible but produces invalid results

  // TODO: find a way to calculate a tighter AABB (in world space) -> transform the triangle into world space and then calculate an aabb
  //       instead of calculating an AABB in lattice space (because it will always be twice as big in lattice space as it has to be
  //       because the triangles have a 90° angle

  // TODO: find out if this is even needed
  float inverseMaxRange = 1.0 / MAX_RANGE;
  vec2 l0 = root.lMin + lTriangle.base * inverseMaxRange;
  vec2 l1 = l0 + vec2(0, lTriangle.range) * inverseMaxRange;
  vec2 l2 = l0 + vec2(lTriangle.range, 0) * inverseMaxRange;
  
  // 1. calculate barycentrics of lTriangle in relation to the rootTriangle (use lattice space)
  vec2 b0 = barycentricsFromLatticeTriangle(lTriangle.base);
  vec2 b1 = barycentricsFromLatticeTriangle(lTriangle.base + ivec2(0, lTriangle.range));
  vec2 b2 = barycentricsFromLatticeTriangle(lTriangle.base + ivec2(0, lTriangle.range));

  // 2. calculate center of hexagon per vertex of rootTriangle (use hash()-function) -> this has to be done per rootTriangle, can precompute!

  // these are stored in h0, h1 and h2!


  // 3. for each of the 3 hexagons, calculate the triangle vertices that are used for blending that specific rootTriangle -> same as in 2., precompute!



  // 4. for each of the 3 hexagon triangles, calculate lTriangle in UV space (use barycentrics calculated in 1. here)
  ivec2 v0_offset = ivec2(0,0);
  ivec2 v1_offset = ivec2(0,1);
  ivec2 v2_offset = ivec2(1,0);
  if (isRangeNegative) {
    v0_offset = ivec2(1,1);
    v1_offset = ivec2(1,0);
    v2_offset = ivec2(0,1);
  }

  vec2 uv0_0 = h0_0 + latticeToWorld * (l0 - (root.lMin + v0_offset));
  vec2 uv0_1 = h0_0 + latticeToWorld * (l1 - (root.lMin + v0_offset));
  vec2 uv0_2 = h0_0 + latticeToWorld * (l2 - (root.lMin + v0_offset));

  vec2 uv1_0 = h1_0 + latticeToWorld * (l0 - (root.lMin + v1_offset));
  vec2 uv1_1 = h1_0 + latticeToWorld * (l1 - (root.lMin + v1_offset));
  vec2 uv1_2 = h1_0 + latticeToWorld * (l2 - (root.lMin + v1_offset));

  vec2 uv2_0 = h2_0 + latticeToWorld * (l0 - (root.lMin + v2_offset));
  vec2 uv2_1 = h2_0 + latticeToWorld * (l1 - (root.lMin + v2_offset));
  vec2 uv2_2 = h2_0 + latticeToWorld * (l2 - (root.lMin + v2_offset));

  // 5. for each of the 3 lTriangle in UV space calculate minmax of height (use heightFromUVTriangle)
  vec2 minmax0 = heightFromUVTriangle(uv0_0, uv0_1, uv0_2);
  vec2 minmax1 = heightFromUVTriangle(uv1_0, uv1_1, uv1_2);
  vec2 minmax2 = heightFromUVTriangle(uv2_0, uv2_1, uv2_2);

  // 6. perform blending 3 of those minmax 3 times (use barycentrics as weights of each of lTriangle's vertices) -> total 6 blendings
  vec2 G0 = b0.x * minmax0 + b0.y * minmax1 + (1 - b0.x - b0.y) * minmax2;
  G0 = G0 - vec2(0.5);
  G0 = G0 * inversesqrt(b0.x * b0.x + b0.y * b0.y + (1 - b0.x - b0.y) * (1 - b0.x - b0.y));
  G0 = G0 + vec2(0.5);

  vec2 G1 = b1.x * minmax0 + b1.y * minmax1 + (1 - b1.x - b1.y) * minmax2;
  G1 = G1 - vec2(0.5);
  G1 = G1 * inversesqrt(b1.x * b1.x + b1.y * b1.y + (1 - b1.x - b1.y) * (1 - b1.x - b1.y));
  G1 = G1 + vec2(0.5);

  vec2 G2 = b2.x * minmax0 + b2.y * minmax1 + (1 - b2.x - b2.y) * minmax2;
  G2 = G2 - vec2(0.5);
  G2 = G2 * inversesqrt(b2.x * b2.x + b2.y * b2.y + (1 - b2.x - b2.y) * (1 - b2.x - b2.y));
  G2 = G2 + vec2(0.5);

  // 7. calculate minmax of these blending results -> interval in which the height can be
  float mininum = clamp(min(G0.x, min(G1.x, G2.x)), 0, 1) * pcRay.displacementAmount;
  float maximum = clamp(max(G0.y, max(G1.y, G2.y)), 0, 1) * pcRay.displacementAmount;

  // 8. calculate affine form from height interval
  vec4 affineHeight = 0.5 * vec4(mininum + maximum, 0, 0, maximum - mininum);

  //vec2 minmax = globalMinMax * pcRay.displacementAmount;
  //vec4 affineHeight = 0.5 * vec4(minmax.x + minmax.y, 0, 0, minmax.y - minmax.x);


  //TODO: adjust this code to fit with LatticeTriangle instead of LatticeTexel

  // 2. calculate affine form [uv] for the triangle -> affine form layout: (xC, xU, xV, xK) -> see equation (12) of TFDM paper
  // layout: (xC, xU, xV, xK)
  // this is just an AABB around the triangle in lattice space
  vec2 medianPoint = l0 + (lTriangle.range / 2.0) * inverseMaxRange;
  vec4 x = vec4(medianPoint.x, (lTriangle.range / 2.0) * inverseMaxRange, 0, 0);
  // layout: (xC, xU, xV, xK)
  vec4 y = vec4(medianPoint.y, 0, (lTriangle.range / 2.0) * inverseMaxRange, 0);

  // 3. calculate affine form [P] for position in 3D space
  mat4x3 xy1 = mat4x3(x.x, y.x, 1,
                      x.y, y.y, 0,
                      x.z, y.z, 0,
                      x.w, y.w, 0);

  mat4x3 affinePos = pt * xy1;

  // 4. calculate affine form [N] for normal in 3D space
  mat4x3 affineNrm = nt * xy1;

  // 5. calculate affine form [S] for displaced surface relative to given texel in 3D space -> [S] = [P] + [h] * [N]
  vec4 row1 = affineFormDot(affineHeight, vec4(affineNrm[0][0], affineNrm[1][0], affineNrm[2][0], affineNrm[3][0]));
  vec4 row2 = affineFormDot(affineHeight, vec4(affineNrm[0][1], affineNrm[1][1], affineNrm[2][1], affineNrm[3][1]));
  vec4 row3 = affineFormDot(affineHeight, vec4(affineNrm[0][2], affineNrm[1][2], affineNrm[2][2], affineNrm[3][2]));
  // the affine form [hn] = [h] * [N]
  mat4x3 hn = mat4x3(row1.x, row2.x, row3.x,
                     row1.y, row2.y, row3.y,
                     row1.z, row2.z, row3.z,
                     row1.w, row2.w, row3.w);
  mat4x3 affineDisp = affinePos + hn;

  // 6. calculate AABB from [S] according to equation (13) of TFDM paper
  Aabb result;
  // TODO: should maybe do this with vector operations in the future for better performance
  result.minimum = vec3(affineDisp[0][0] - abs(affineDisp[1][0]) - abs(affineDisp[2][0]) - abs(affineDisp[3][0]),
                        affineDisp[0][1] - abs(affineDisp[1][1]) - abs(affineDisp[2][1]) - abs(affineDisp[3][1]),
                        affineDisp[0][2] - abs(affineDisp[1][2]) - abs(affineDisp[2][2]) - abs(affineDisp[3][2]));
  result.maximum = vec3(affineDisp[0][0] + abs(affineDisp[1][0]) + abs(affineDisp[2][0]) + abs(affineDisp[3][0]),
                        affineDisp[0][1] + abs(affineDisp[1][1]) + abs(affineDisp[2][1]) + abs(affineDisp[3][1]),
                        affineDisp[0][2] + abs(affineDisp[1][2]) + abs(affineDisp[2][2]) + abs(affineDisp[3][2]));

  return result;
}

// TODO: in the future triforceTraversal should be called twice inside of latticeTraversal! would get rid of some edge cases and make better performance
//         -> this would remove the next() function on the highest level (if range = MAX_RANGE)
float triforceTraversal(LatticeTexel root, out vec3 debugColor) {
  float tHit = -1;
  LatticeTriangle lTriangle;
  lTriangle.base    = ivec2(0,0);
  lTriangle.range   = MAX_RANGE;
  lTriangle.counter = 0;

  mat3x3 pt = mat3x3(triangle.v0.pos, triangle.v1.pos, triangle.v2.pos) * lToB;
  mat3x3 nt = mat3x3(triangle.v0.nrm, triangle.v1.nrm, triangle.v2.nrm) * lToB;
  
  // there are only 2 triangles on the highest level:
  //   bottom:  base = (0,0)                    range =  MAX_RANGE    counter = 0
  //   top:     base = (MAX_RANGE,MAX_RANGE)    range = -MAX_RANGE    counter = 1
  //   so this stops when next() got called upon the "top" triangle, which produces
  //   invalid: base = (0,0)                    range =  MAX_RANGE    counter = 2
  while (!(abs(lTriangle.range) == MAX_RANGE && lTriangle.counter > 1)) {
    if (lTriangle.range == MAX_RANGE) {
      isRangeNegative = false;
      h0_0 = hash(root.lMin);
      h1_0 = hash(root.lMin + ivec2(0,1));
      h2_0 = hash(root.lMin + ivec2(1,0));
    } else if (lTriangle.range == -MAX_RANGE) {
      isRangeNegative = true;
      h0_0 = hash(root.lMin + ivec2(1,1));
      h1_0 = hash(root.lMin + ivec2(1,0));
      h2_0 = hash(root.lMin + ivec2(0,1));
    }
    if(triforceOutside(lTriangle)) {
	  triforceNext(lTriangle);
	  continue;
	}
	Aabb aabb = triforceBox(lTriangle, root, pt, nt);
	float hitAABB = hitAabb(aabb, ray);
    // if AABB wasn't hit
	if (!(hitAABB < -1.0 || hitAABB > -1.0)) {
	  triforceNext(lTriangle);
	 // if smallest lattice texel is reached
	} else if (abs(lTriangle.range) <= 1) {
      float hit = hitAABB;
      if (hit >= 0 && (tHit < 0 || hit < tHit)) {
        debugColor = vec3((lTriangle.base + root.lMin), 0);
        tHit = hit;
        // TODO: set texture coordinates here
      }
      triforceNext(lTriangle);
	} else {
	  triforceDown(lTriangle);
	}
  }
  // TODO: set tex coords somewhere
  //intPayload.worldNrm = vec3(0,1,0);
  return tHit;
}

// -----------------------------------------------------------------------------------------------------------
// lattice descend

bool latticeTexelEquals(LatticeTexel t1, LatticeTexel t2) {
  if (t1.lMin == t2.lMin && t1.range == t2.range && t1.counter == t2.counter)
    return true;
  return false;
}

void latticeDown(inout LatticeTexel lTexel) {
  lTexel.range /= 2;
  lTexel.counter = 0;
}

// will only be called if lTexel.counter = 3 -> texel is at topRight
void latticeUp(inout LatticeTexel lTexel, LatticeTexel root) {
  lTexel.lMin.x -= lTexel.range;
  lTexel.lMin.y -= lTexel.range;
  lTexel.range *= 2;
  ivec2 temp = (lTexel.lMin - root.lMin) % (lTexel.range * 2);
  lTexel.counter = 2 * (temp.x / lTexel.range) + temp.y / lTexel.range;
}

void latticeNext(inout LatticeTexel lTexel, LatticeTexel root) {
  while (true) {
    switch(lTexel.counter) {
	// texelCoord = (0,1)
    case 1:
      lTexel.lMin += ivec2(lTexel.range, -lTexel.range);
	  lTexel.counter++;
      return;

    // texelCoord = (1,1)
    case 3:
      latticeUp(lTexel, root);
      continue;

    // texelCoord = (0,0) or (1,0)
    default:
      lTexel.lMin.y += lTexel.range;
	  lTexel.counter++;
      return;
	}
  }
}

// acts similar as the "box" function but for lattice-space -> need to adjust for this purpose
Aabb latticeBox(LatticeTexel lTexel, mat3x3 pt, mat3x3 nt) {
  // 1. calculate affine form [h] of height range from minmax
  // TODO: blending min and blending max of globalMinMax has to be calculated and used here -> blending is not convex!
  vec2 minmax = globalMinMax * pcRay.displacementAmount;
  vec4 affineHeight = 0.5 * vec4(minmax.x + minmax.y, 0, 0, minmax.y - minmax.x);

  // 2. calculate affine form [uv] for the texel -> affine form layout: (xC, xU, xV, xK) -> see equation (12) of TFDM paper
  // layout: (xC, xU, xV, xK)
  vec4 x = vec4(lTexel.lMin.x + (lTexel.range / 2.0), lTexel.range / 2.0, 0, 0);
  // layout: (xC, xU, xV, xK)
  vec4 y = vec4(lTexel.lMin.y + (lTexel.range / 2.0), 0, lTexel.range / 2.0, 0);

  // 3. calculate affine form [P] for position in 3D space
  mat4x3 xy1 = mat4x3(x.x, y.x, 1,
                      x.y, y.y, 0,
                      x.z, y.z, 0,
                      x.w, y.w, 0);

  mat4x3 affinePos = pt * xy1;

  // 4. calculate affine form [N] for normal in 3D space
  mat4x3 affineNrm = nt * xy1;

  // 5. calculate affine form [S] for displaced surface relative to given texel in 3D space -> [S] = [P] + [h] * [N]
  vec4 row1 = affineFormDot(affineHeight, vec4(affineNrm[0][0], affineNrm[1][0], affineNrm[2][0], affineNrm[3][0]));
  vec4 row2 = affineFormDot(affineHeight, vec4(affineNrm[0][1], affineNrm[1][1], affineNrm[2][1], affineNrm[3][1]));
  vec4 row3 = affineFormDot(affineHeight, vec4(affineNrm[0][2], affineNrm[1][2], affineNrm[2][2], affineNrm[3][2]));
  // the affine form [hn] = [h] * [N]
  mat4x3 hn = mat4x3(row1.x, row2.x, row3.x,
                     row1.y, row2.y, row3.y,
                     row1.z, row2.z, row3.z,
                     row1.w, row2.w, row3.w);
  mat4x3 affineDisp = affinePos + hn;

  // 6. calculate AABB from [S] according to equation (13) of TFDM paper
  Aabb result;
  // TODO: should maybe do this with vector operations in the future for better performance
  result.minimum = vec3(affineDisp[0][0] - abs(affineDisp[1][0]) - abs(affineDisp[2][0]) - abs(affineDisp[3][0]),
                        affineDisp[0][1] - abs(affineDisp[1][1]) - abs(affineDisp[2][1]) - abs(affineDisp[3][1]),
                        affineDisp[0][2] - abs(affineDisp[1][2]) - abs(affineDisp[2][2]) - abs(affineDisp[3][2]));
  result.maximum = vec3(affineDisp[0][0] + abs(affineDisp[1][0]) + abs(affineDisp[2][0]) + abs(affineDisp[3][0]),
                        affineDisp[0][1] + abs(affineDisp[1][1]) + abs(affineDisp[2][1]) + abs(affineDisp[3][1]),
                        affineDisp[0][2] + abs(affineDisp[1][2]) + abs(affineDisp[2][2]) + abs(affineDisp[3][2]));

  return result;
}

// TODO: should act similar as the "outside" function but for lattice-space -> need to adjust for this purpose
bool latticeOutside(LatticeTexel lTexel) {
  return false;
}
// TODO: should determine somewhere inside, which lattice-triangle is hit and then call the 2nd hierarchy from there
//         -> if 2nd hierarchy hit is negative, continue with the 1st hierarchy again (lattice-triangle)
float latticeTraversal(LatticeTexel root) {
  float tHit = -1;
  LatticeTexel lTexel, endTexel;
  lTexel = root;
  endTexel = root;
  latticeNext(endTexel, root);

  mat3x3 pt = mat3x3(triangle.v0.pos, triangle.v1.pos, triangle.v2.pos) * lToB;
  mat3x3 nt = mat3x3(triangle.v0.nrm, triangle.v1.nrm, triangle.v2.nrm) * lToB;
  
  while (!latticeTexelEquals(lTexel, endTexel)) {
    if(latticeOutside(lTexel)) {
	  latticeNext(lTexel, root);
	  continue;
	}
	Aabb aabb = latticeBox(lTexel, pt, nt);
	float hitAABB = hitAabb(aabb, ray);
    // if AABB wasn't hit
	if (!(hitAABB < -1.0 || hitAABB > -1.0)) {
	  latticeNext(lTexel, root);
	 // if smallest lattice texel is reached
	} else if (lTexel.range <= 1) {
      //         -> transform into world space and perform intersection test to determine in which triangle the hit is
	  // TODO: traverse 2nd hierarchy (-> triforce traversal)
      vec3 debugColor = vec3(lTexel.lMin, 0);
      float hit = triforceTraversal(lTexel, debugColor);
      //float hit = hitAABB;
      if (hit >= 0 && (tHit < 0 || hit < tHit)) {
        intPayload.debugColor = debugColor;
        tHit = hit;
        // TODO: set texture coordinates here
      }
      latticeNext(lTexel, root);
	} else {
	  latticeDown(lTexel);
	}
  }
  // TODO: set tex coords somewhere
  intPayload.worldNrm = vec3(0,1,0);
  return tHit;
}


void main()
{
  // Grab the ray
  ray.origin    = gl_WorldRayOriginEXT;
  ray.direction = gl_WorldRayDirectionEXT;

  // Grab the object description
  DispObjDesc  objResource = dispObjDesc.i[gl_InstanceCustomIndexEXT];
  MatIndices   matIndices  = MatIndices(objResource.materialIndexAddress);
  Materials    materials   = Materials(objResource.materialAddress);
  Indices      indices     = Indices(objResource.indexAddress);
  Vertices     vertices    = Vertices(objResource.vertexAddress);

  // Indices of the triangle
  ivec3 ind = indices.i[gl_PrimitiveID];
  
  // Vertex of the triangle
  Vertex v0 = vertices.v[ind.x];
  Vertex v1 = vertices.v[ind.y];
  Vertex v2 = vertices.v[ind.z];

  // Material of the object
  int               matIdx = matIndices.i[gl_PrimitiveID];
  WaveFrontMaterial mat    = materials.m[matIdx];

  // set triangle data that gets used by various intersection methods
  triangle.v0 = v0;
  triangle.v1 = v1;
  triangle.v2 = v2;
  triangle.txtOffset = mat.dispTextureID + dispObjDesc.i[gl_InstanceCustomIndexEXT].txtOffset;

  // if a triangle is not displaced
  if (mat.dispTextureID < 0 || pcRay.displacementAmount <= 0)
  {
    vec3 tHit = hitTriangle(triangle, ray);
    if (tHit.z < 0)
      return;
    intPayload.worldNrm = v0.nrm * (1 - tHit.x - tHit.y) + v1.nrm * tHit.x + v2.nrm * tHit.y;
    intPayload.texCoord = v0.texCoord * (1 - tHit.x - tHit.y) + v1.texCoord * tHit.x + v2.texCoord * tHit.y;
    reportIntersectionEXT(tHit.z, KIND_TRIANGLE);
    return;
  }

  float newHit = -1;
  if (pcRay.raymarching == 2) {
    // fetch AABB
    Aabb aabb = Aabbs(objResource.aabbAddress).b[gl_PrimitiveID];

    newHit = raymarching(aabb);
  } else if (pcRay.raymarching == 0) {
    // fetch UV to barycentrics matrix
    uvToB = UVtoBs(objResource.uvToBAddress).m[gl_PrimitiveID];

    // TODO: signum is 0, if all vertices are within one line, needs adjustment for degenerated triangles
    // compute outward facing normals in UV space for use in Triangle-square 2D collision
    // signum is 1, if vertices are clockwise, -1 else
    float signum = sign(determinant(mat3(v0.texCoord.x, v1.texCoord.x, v2.texCoord.x,
                                          v0.texCoord.y, v1.texCoord.y, v2.texCoord.y,
                                          1,             1,             1)));
    // TODO: find out if normalization is even necessary
    n0 = signum * normalize(v1.texCoord - v0.texCoord);
    n1 = signum * normalize(v2.texCoord - v1.texCoord);
    n2 = signum * normalize(v0.texCoord - v2.texCoord);

    // 90° clockwise rotation
    n0 = vec2(n0.y, -n0.x);
    n1 = vec2(n1.y, -n1.x);
    n2 = vec2(n2.y, -n2.x);

    // TODO: remove this debug color
    intPayload.debugColor = vec3(1,0,0);
    newHit = traversal(pcRay.targetLod);
  } else {
    // procedural TFDM

    // calculate lattice coords for vertices
	// TODO: store these for all the shader -> allocate outside main
    vec2 l0 = uvToLattice(v0.texCoord, pcRay.blendingOffset);
    vec2 l1 = uvToLattice(v1.texCoord, pcRay.blendingOffset);
    vec2 l2 = uvToLattice(v2.texCoord, pcRay.blendingOffset);

    // lattice to barycentrics
    lToB = mat3(l0.x, l0.y, 1,
                l1.x, l1.y, 1,
                l2.x, l2.y, 1);
    lToB = inverse(lToB);
	
	// precalculate outward facing normals of triangle in lattice space for Triangle-square 2D collision
	//   -> reusing n0, n1, n2
	float signum = sign(determinant(mat3(l0.x, l1.x, l2.x,
                                         l0.y, l1.y, l2.y,
                                         1,    1,    1)));

    n0 = signum * normalize(l1 - l0);
    n1 = signum * normalize(l2 - l1);
    n2 = signum * normalize(l0 - l2);
	
	// 90° clockwise rotation
    n0 = vec2(n0.y, -n0.x);
    n1 = vec2(n1.y, -n1.x);
    n2 = vec2(n2.y, -n2.x);

    vec2 lMin = min(l0, min(l1, l2));
    vec2 lMax = max(l0, max(l1, l2));

    ivec2 lAlignedMin  = ivec2(floor(lMin));
    ivec2 lAlignedMax  = ivec2(ceil(lMax));
    int range = max(lAlignedMax.x - lAlignedMin.x, lAlignedMax.y - lAlignedMin.y);
    int power = 1;
    while(power < range)
      power *= 2;
	
	LatticeTexel root;
	root.lMin = lAlignedMin;
	root.range = power;
	root.counter = 0;

    int lod = 0;
    while (textureSize(textureSamplers[nonuniformEXT(triangle.txtOffset)], lod).x != 1)
      lod++;
    globalMinMax = texelFetch(textureSamplers[nonuniformEXT(triangle.txtOffset)], ivec2(0,0), lod).yz;
    globalMinMax.x = clamp(min(globalMinMax.x, (globalMinMax.x - 0.5) / (sqrt(3.0) / 3) + 0.5), 0, 1);
    globalMinMax.y = clamp(max(globalMinMax.y, (globalMinMax.y - 0.5) / (sqrt(3.0) / 3) + 0.5), 0, 1);

    intPayload.debugColor = vec3(1,0,1);
    newHit = latticeTraversal(root);
  }
  
  if (newHit > 0)
    reportIntersectionEXT(newHit, KIND_TRIANGLE);
}